CTF: LazyAdmin
Descrição: Easy Linux machine to practice your skills
Nível: Fácil
Tipo: Web / Linux
Objetivo: user_flag / root_flag

Iniciei o reconhecimento com o comando nmap -sV -v <ip>, que identificou dois serviços principais: Apache rodando na porta web padrão e OpenSSH, ambos em ambiente Ubuntu. Com isso, avancei para enumeração de diretórios utilizando gobuster dir -u <ip> -w common.txt, o que revelou o diretório /content. Uma segunda varredura em /content, usando a mesma wordlist, identificou caminhos internos importantes: /content/as e /content/inc, que se tornaram os vetores centrais da exploração.

No diretório /content/as, encontrei uma instalação do CMS SweetRice. Já em /content/inc, havia estruturas internas do CMS, incluindo uma pasta de backup contendo arquivos SQL. Esses arquivos traziam credenciais do administrador do SweetRice em formato de hash. Após quebrar o hash em ferramenta local e descobrir a senha real, consegui acessar o painel administrativo do SweetRice. Dentro do painel, notei que a seção responsável por anúncios podia enviar arquivos diretamente para o diretório /content/inc/ads, sem validação adequada, o que é um vetor clássico de Remote Code Execution em instalações mal configuradas. Preparei então um payload de reverse shell em PHP, mantendo a estrutura clássica de execução via /bin/bash e redirecionamento para meu endereço local, e enviei esse arquivo pela interface de anúncios. Ao acessar o arquivo pelo navegador e mantendo o Netcat ouvindo na porta configurada, recebi um shell interativo na máquina. Para torná-lo mais utilizável, converti-o em um pseudo-terminal usando Python, com o comando que invoca o módulo pty e solicita um spawn de /bin/bash.

Dentro da máquina, explorei o diretório do usuário itguy, onde encontrei a user.txt. No mesmo diretório, o arquivo backup.sh chamou atenção por ser parte de um processo de rotina. A análise revelou que esse script utilizava sudo para executar o arquivo /etc/copy.sh sem pedir senha. Verifiquei as permissões e notei que o /etc/copy.sh era modificável pelo meu usuário atual. Isso abriu um vetor de escalada de privilégios baseado em sudo misconfiguration combinado com writable script. Substituí então o conteúdo do arquivo por um reverse shell direcionado ao meu endereço, usando a técnica do mkfifo somada ao fluxo bidirecional via sh e Netcat. Após configurar o listener novamente, bastou executar manualmente o backup.sh ou aguardar sua execução automática. Assim que o processo chamou o copy.sh, recebi um novo shell, agora com privilégio total de root.

Com isso, acessei o diretório /root, recuperei o arquivo root.txt e finalizei o CTF com êxito, validando toda a cadeia de exploração: enumeração web, descoberta de CMS vulnerável, RCE via upload de anúncios, acesso inicial, análise de scripts internos, identificação de escalada baseada em sudo e obtenção final de root.
